package com.javarush.task.task30.task3013;

/* 
Набираем код Ӏ Java Multithreading: 10 уровень, 6 лекция
*/

public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int number = Integer.MAX_VALUE - 133; //-------------РАСКОММЕНТИТЬ
        //int number = 3456;                       //-------------ЗАКОММЕНТИТЬ
        System.out.println(Integer.toString(number, 2));

        String result = Integer.toString(solution.resetLowerBits(number), 2);
        System.out.println(result);
        //System.out.println(solution.resetLowerBits(number)); //-----ЗАКОММЕНТИТЬ
    }

    public int resetLowerBits(int number) {
        //напишите тут ваш код
        //number >>= 1;

//1.Понять что в int - 32 ячейки для битов.
//2.Количество битов, занимаемых заданным числом (например число 6 - это бинарное 110, т.е. три бита. Остальные биты левее заполняются нулями.
//Далее нужно все биты этого числа превратить в "1"! Что мы и делаем number |= number >> 1; вот этими операциями.
//Затем переворачиваем  число ~number получив 29 ячеек "1" и 3 ячейки "0", тут же сдвигаем биты вправо  и нулей становится 2.
//И на конец через "&" сравниваем полученное число с тем, где наши 3 бита были единицами:
//11111111111111111111111111111100
//00000000000000000000000000000111
//Ну а тут совпадение только в одном месте. Где нам и нужно.

        //number     = 3456
        //number     = 00000000 00000000 00001101 10000000
        //number >>  = 00000000 00000000 00000110 11000000
        //   |=      = 00000000 00000000 00001111 11000000
        number |= number >> 1;

        //number     = 00000000 00000000 00001111 11000000
        //number >>2 = 00000000 00000000 00000011 11110000
        //   |=      = 00000000 00000000 00001111 11110000
        number |= number >> 2;

        //number     = 00000000 00000000 00001111 11110000
        //number >>4 = 00000100 00100011 10100011 00010111
        //   |=      = 00000100 00100011 10101111 11110111

        number |= number >> 4;

        //number     = 00000100 00100011 10101111 11110111
        //number >>8 = 00000000 00000100 00100011 10101111
        //   |=      = 00000100 00100111 10101111 11111111

        number |= number >> 8;

        //number     = 00000100 00100111 10101111 11111111
        //number >>16=                        100 00100111
        //   |=      = 00000100 00100111 10101111 11111111

        number |= number >> 16;

        //number     = 00000100 00100111 10101111 11111111
        //~number    = 00000100 00100111 10110000 00000000
        //    &=     = 00000100 00100111 10100000 00000000
        number &= ~number >> 1;


        //return Integer.highestOneBit(number);
        return number;
    }
}